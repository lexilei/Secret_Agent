"""
HTML report generator for benchmark results.

Creates comprehensive, interactive HTML reports with charts and tables.
"""

from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional
import json

from ..metrics.aggregator import AggregatedMetrics, MetricsAggregator
from ..experiments.base import ExperimentResult
from .charts import ChartGenerator


class ReportGenerator:
    """
    Generate interactive HTML reports for benchmark results.

    Usage:
        generator = ReportGenerator(output_dir="./reports")
        report_path = generator.generate_full_report(experiment_metrics, detailed_results)
    """

    def __init__(self, output_dir: Path = Path("./benchmark_results")):
        """
        Initialize report generator.

        Args:
            output_dir: Directory to save reports
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.charts = ChartGenerator()

    def generate_full_report(
        self,
        experiment_metrics: Dict[str, AggregatedMetrics],
        detailed_results: Optional[Dict[str, List[ExperimentResult]]] = None,
        learning_curves: Optional[Dict[str, List[Dict]]] = None,
    ) -> Path:
        """
        Generate complete HTML report with all sections.

        Args:
            experiment_metrics: Dict of experiment name to AggregatedMetrics
            detailed_results: Optional detailed results per experiment
            learning_curves: Optional learning curve data for L5 experiments

        Returns:
            Path to generated report
        """
        # Generate all sections
        summary_html = self._render_summary(experiment_metrics)
        comparison_table = self._render_comparison_table(experiment_metrics)
        charts_html = self._render_charts(experiment_metrics, learning_curves)
        calculator_html = self._render_calculator_breakdown(experiment_metrics)

        # Assemble full report
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MedCalc-Bench Benchmark Results</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        {self._get_styles()}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MedCalc-Bench Benchmark Results</h1>
            <p class="subtitle">ptool_framework Ablation Study</p>
            <p class="timestamp">Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
        </header>

        <nav>
            <a href="#summary">Summary</a>
            <a href="#comparison">Comparison</a>
            <a href="#charts">Charts</a>
            <a href="#breakdown">Per-Calculator</a>
        </nav>

        <section id="summary">
            <h2>Executive Summary</h2>
            {summary_html}
        </section>

        <section id="comparison">
            <h2>Experiment Comparison</h2>
            {comparison_table}
        </section>

        <section id="charts">
            <h2>Visualizations</h2>
            {charts_html}
        </section>

        <section id="breakdown">
            <h2>Per-Calculator Breakdown</h2>
            {calculator_html}
        </section>

        <footer>
            <p>Generated by ptool_framework benchmark suite</p>
        </footer>
    </div>
</body>
</html>"""

        # Save report
        report_path = self.output_dir / "report.html"
        report_path.write_text(html)

        # Also save raw data as JSON
        data_path = self.output_dir / "metrics.json"
        data_path.write_text(json.dumps(
            {name: m.to_dict() for name, m in experiment_metrics.items()},
            indent=2,
            default=str,
        ))

        return report_path

    def _render_summary(self, metrics: Dict[str, AggregatedMetrics]) -> str:
        """Render executive summary section."""
        if not metrics:
            return "<p>No results available</p>"

        # Find best experiment
        best_exp = max(metrics.items(), key=lambda x: x[1].accuracy_tolerance)
        baseline = metrics.get("baseline")

        # Calculate improvement
        improvement = ""
        if baseline:
            imp_pct = (best_exp[1].accuracy_tolerance - baseline.accuracy_tolerance) * 100
            improvement = f"<p><strong>Best improvement over baseline:</strong> +{imp_pct:.1f} percentage points</p>"

        total_instances = next(iter(metrics.values())).total_instances if metrics else 0
        total_cost = sum(m.total_cost_usd for m in metrics.values())

        return f"""
<div class="summary-cards">
    <div class="card">
        <h3>Experiments Run</h3>
        <div class="value">{len(metrics)}</div>
    </div>
    <div class="card">
        <h3>Instances per Experiment</h3>
        <div class="value">{total_instances}</div>
    </div>
    <div class="card">
        <h3>Best Accuracy</h3>
        <div class="value">{best_exp[1].accuracy_tolerance * 100:.1f}%</div>
        <div class="label">{best_exp[0]}</div>
    </div>
    <div class="card">
        <h3>Total Cost</h3>
        <div class="value">${total_cost:.4f}</div>
    </div>
</div>
{improvement}
"""

    def _render_comparison_table(self, metrics: Dict[str, AggregatedMetrics]) -> str:
        """Render comparison table."""
        if not metrics:
            return "<p>No results available</p>"

        rows = ""
        for name, m in sorted(metrics.items(), key=lambda x: x[1].accuracy_tolerance, reverse=True):
            rows += f"""
<tr>
    <td><strong>{name}</strong></td>
    <td>{m.experiment_level}</td>
    <td>{m.accuracy_tolerance * 100:.1f}%</td>
    <td>{m.accuracy_exact * 100:.1f}%</td>
    <td>${m.total_cost_usd:.4f}</td>
    <td>{m.avg_latency_ms:.0f} ms</td>
    <td>{m.total_tokens:,}</td>
    <td>{m.error_rate * 100:.1f}%</td>
</tr>"""

        return f"""
<table>
    <thead>
        <tr>
            <th>Experiment</th>
            <th>Level</th>
            <th>Accuracy (Â±5%)</th>
            <th>Exact Match</th>
            <th>Cost</th>
            <th>Avg Latency</th>
            <th>Total Tokens</th>
            <th>Error Rate</th>
        </tr>
    </thead>
    <tbody>
        {rows}
    </tbody>
</table>
"""

    def _render_charts(
        self,
        metrics: Dict[str, AggregatedMetrics],
        learning_curves: Optional[Dict[str, List[Dict]]] = None,
    ) -> str:
        """Render charts section."""
        charts = []

        # Accuracy comparison
        charts.append(f"""
<div class="chart-container">
    {self.charts.accuracy_comparison(metrics)}
</div>
""")

        # Improvement over baseline
        if "baseline" in metrics:
            charts.append(f"""
<div class="chart-container">
    {self.charts.improvement_over_baseline(metrics)}
</div>
""")

        # Cost vs accuracy
        charts.append(f"""
<div class="chart-container">
    {self.charts.cost_vs_accuracy_scatter(metrics)}
</div>
""")

        # Category comparison
        charts.append(f"""
<div class="chart-container">
    {self.charts.category_comparison(metrics)}
</div>
""")

        # Learning curves for L5
        if learning_curves:
            for name, curve in learning_curves.items():
                if curve:
                    charts.append(f"""
<div class="chart-container">
    {self.charts.learning_curve(curve, name)}
</div>
""")

        return "\n".join(charts)

    def _render_calculator_breakdown(self, metrics: Dict[str, AggregatedMetrics]) -> str:
        """Render per-calculator breakdown."""
        # Heatmap
        heatmap = self.charts.per_calculator_heatmap(metrics)

        # Detailed table for best experiment
        best_exp = max(metrics.items(), key=lambda x: x[1].accuracy_tolerance)
        calc_rows = ""
        for calc_name, calc_m in sorted(
            best_exp[1].by_calculator.items(),
            key=lambda x: x[1].accuracy_tolerance,
            reverse=True,
        ):
            calc_rows += f"""
<tr>
    <td>{calc_name}</td>
    <td>{calc_m.total_instances}</td>
    <td>{calc_m.accuracy_tolerance * 100:.1f}%</td>
    <td>${calc_m.avg_cost_usd:.5f}</td>
    <td>{calc_m.avg_latency_ms:.0f} ms</td>
</tr>"""

        return f"""
<div class="chart-container">
    {heatmap}
</div>

<h3>Detail for Best Experiment ({best_exp[0]})</h3>
<table>
    <thead>
        <tr>
            <th>Calculator</th>
            <th>Instances</th>
            <th>Accuracy</th>
            <th>Avg Cost</th>
            <th>Avg Latency</th>
        </tr>
    </thead>
    <tbody>
        {calc_rows}
    </tbody>
</table>
"""

    def _get_styles(self) -> str:
        """Return CSS styles for the report."""
        return """
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    line-height: 1.6;
    color: #333;
    background: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    padding: 40px 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 10px;
    margin-bottom: 30px;
}

header h1 {
    font-size: 2.5em;
    margin-bottom: 10px;
}

.subtitle {
    font-size: 1.2em;
    opacity: 0.9;
}

.timestamp {
    font-size: 0.9em;
    opacity: 0.7;
    margin-top: 10px;
}

nav {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin-bottom: 30px;
    padding: 15px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

nav a {
    color: #667eea;
    text-decoration: none;
    font-weight: 500;
    padding: 8px 16px;
    border-radius: 4px;
    transition: background 0.2s;
}

nav a:hover {
    background: #f0f0f0;
}

section {
    background: white;
    padding: 30px;
    border-radius: 10px;
    margin-bottom: 30px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

h2 {
    color: #333;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid #667eea;
}

h3 {
    color: #555;
    margin: 20px 0 15px;
}

.summary-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.card {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
}

.card h3 {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 10px;
}

.card .value {
    font-size: 2em;
    font-weight: bold;
    color: #667eea;
}

.card .label {
    font-size: 0.85em;
    color: #888;
    margin-top: 5px;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #eee;
}

th {
    background: #f8f9fa;
    font-weight: 600;
    color: #555;
}

tr:hover {
    background: #f8f9fa;
}

.chart-container {
    margin: 30px 0;
    padding: 20px;
    background: #fafafa;
    border-radius: 8px;
}

footer {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 0.9em;
}

@media (max-width: 768px) {
    .container {
        padding: 10px;
    }

    header h1 {
        font-size: 1.8em;
    }

    nav {
        flex-wrap: wrap;
    }

    table {
        font-size: 0.9em;
    }

    th, td {
        padding: 8px 10px;
    }
}
"""
