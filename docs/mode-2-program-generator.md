# Mode 2: Program Generator

**Generate complete Python programs from task descriptions.**

Give the framework a description of what you want to accomplish, and it generates a complete program with ptools and workflow logic.

---

## Quick Example

```python
from ptool_framework import generate_program

result = generate_program(
    task_description="Analyze customer reviews for sentiment and key issues",
    input_spec={"review": "Customer review text"},
    output_spec="Analysis with sentiment, issues, and suggested response"
)

print(result.code)
# Saves to review_analyzer.py
```

**Generated output:**

```python
#!/usr/bin/env python3
"""
Review Analyzer: Analyze customer reviews for sentiment and key issues
Generated by ptool_framework
"""

from ptool_framework import ptool
from typing import Dict, List, Any

@ptool(model="deepseek-v3")
def extract_sentiment(review: str) -> Dict[str, Any]:
    """Extract sentiment from a customer review.

    Return {
        "sentiment": "positive" | "negative" | "neutral",
        "confidence": float 0-1,
        "emotional_tone": str
    }
    """
    ...

@ptool(model="deepseek-v3")
def identify_issues(review: str) -> List[str]:
    """Identify specific issues or complaints in the review."""
    ...

@ptool(model="deepseek-v3")
def generate_response(review: str, sentiment: str, issues: List[str]) -> str:
    """Generate an appropriate customer service response."""
    ...

def analyze_review(review: str) -> Dict[str, Any]:
    """Main workflow: Analyze a customer review."""
    sentiment_data = extract_sentiment(review)
    issues = identify_issues(review)
    response = generate_response(review, sentiment_data["sentiment"], issues)

    return {
        "sentiment": sentiment_data,
        "issues": issues,
        "suggested_response": response
    }

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        result = analyze_review(sys.argv[1])
        print(result)
```

---

## How It Works

```
┌────────────────────────────────────────────────────────────┐
│  "Analyze customer reviews for sentiment and issues"       │
│       │                                                     │
│       ▼                                                     │
│  ┌─────────────────────────────────────┐                   │
│  │ 1. analyze_task() [LLM]             │                   │
│  │    - Understand the task            │                   │
│  │    - Identify subtasks              │                   │
│  │    - Determine data flow            │                   │
│  └─────────────────────────────────────┘                   │
│       │                                                     │
│       ▼                                                     │
│  ┌─────────────────────────────────────┐                   │
│  │ 2. design_ptools() [LLM]            │                   │
│  │    - Create ptool signatures        │                   │
│  │    - Write docstrings               │                   │
│  │    - Define types                   │                   │
│  └─────────────────────────────────────┘                   │
│       │                                                     │
│       ▼                                                     │
│  ┌─────────────────────────────────────┐                   │
│  │ 3. generate_workflow() [LLM]        │                   │
│  │    - Create main function           │                   │
│  │    - Wire ptools together           │                   │
│  │    - Add error handling             │                   │
│  └─────────────────────────────────────┘                   │
│       │                                                     │
│       ▼                                                     │
│  ┌─────────────────────────────────────┐                   │
│  │ 4. assemble_program()               │                   │
│  │    - Add imports                    │                   │
│  │    - Add CLI entry point            │                   │
│  │    - Format and validate            │                   │
│  └─────────────────────────────────────┘                   │
│       │                                                     │
│       ▼                                                     │
│  review_analyzer.py                                         │
└────────────────────────────────────────────────────────────┘
```

---

## API Reference

### generate_program()

```python
from ptool_framework import generate_program

result = generate_program(
    task_description="What the program should do",
    input_spec={"param1": "description", "param2": "description"},
    output_spec="Description of expected output",
    output_path="my_program.py",  # Optional: save to file
    model="deepseek-v3",          # Optional: which LLM to use
)

# Result contains:
result.code          # The generated Python code
result.output_path   # Where it was saved (if specified)
result.ptools        # List of generated ptool definitions
result.workflow      # The main workflow function
```

### ProgramGenerator class

For more control:

```python
from ptool_framework import ProgramGenerator

generator = ProgramGenerator(
    model="deepseek-v3",
    max_ptools=10,      # Limit number of ptools
    include_cli=True,   # Add CLI entry point
)

# Step by step
analysis = generator.analyze_task("Analyze customer reviews")
ptools = generator.design_ptools(analysis)
workflow = generator.generate_workflow(ptools)
program = generator.assemble(ptools, workflow)

# Or all at once
program = generator.generate("Analyze customer reviews")
```

---

## Using Templates

Pre-built templates for common patterns:

```python
from ptool_framework import generate_from_template

# Analyzer template: Extract → Analyze → Summarize
program = generate_from_template(
    template="analyzer",
    task="Analyze financial reports for risk indicators",
    output_path="risk_analyzer.py"
)

# Classifier template: Classify → Explain
program = generate_from_template(
    template="classifier",
    task="Classify support tickets by department",
    output_path="ticket_classifier.py"
)

# Extractor template: Extract entities → Extract relationships
program = generate_from_template(
    template="extractor",
    task="Extract people and their roles from news articles",
    output_path="news_extractor.py"
)
```

---

## CLI Usage

```bash
# Generate a program
ptool generate "Analyze customer reviews" -o analyzer.py

# Use a specific model
ptool generate "Complex analysis task" -o analyzer.py --model gpt-4o

# Use a template
ptool generate "Classify documents" -o classifier.py --template classifier

# Dry run (show what would be generated)
ptool generate "Task description" --dry-run
```

---

## Example: Full Workflow

### 1. Generate the Program

```python
from ptool_framework import generate_program, enable_tracing

# Generate
result = generate_program(
    task_description="Extract food items from meal descriptions and analyze nutritional content",
    input_spec={"description": "A meal description like 'I had pizza and salad for lunch'"},
    output_spec="List of foods with nutritional estimates",
    output_path="meal_analyzer.py"
)

print(f"Generated: {result.output_path}")
```

### 2. Run with Trace Collection

```python
enable_tracing(True)

from meal_analyzer import analyze_meal

# Run on test data
test_meals = [
    "I had a caesar salad with grilled chicken",
    "Breakfast was eggs, bacon, and toast",
    "Grabbed a burger and fries for lunch",
]

for meal in test_meals:
    result = analyze_meal(meal)
    print(f"Meal: {meal}")
    print(f"Result: {result}")
    print()
```

### 3. Analyze and Optimize

```bash
# See distillation candidates
ptool analyze meal_analyzer.py

# Distill common patterns to Python
ptool refactor meal_analyzer.py --mode distill -o meal_analyzer_v2.py
```

---

## Generated Program Structure

Every generated program has:

```python
#!/usr/bin/env python3
"""
[Program Name]: [Task description]
Generated by ptool_framework
"""

# ============== Imports ==============
from ptool_framework import ptool
from typing import Dict, List, Any, Literal, Optional

# ============== Configuration ==============
DEFAULT_MODEL = "deepseek-v3"

# ============== PTools ==============
@ptool(model=DEFAULT_MODEL)
def ptool_1(param: str) -> ReturnType:
    """Docstring explaining what this does."""
    ...

@ptool(model=DEFAULT_MODEL)
def ptool_2(param: str) -> ReturnType:
    """Docstring explaining what this does."""
    ...

# ============== Main Workflow ==============
def main_workflow(input_param: str) -> OutputType:
    """Main workflow that orchestrates the ptools."""
    step1 = ptool_1(input_param)
    step2 = ptool_2(step1)
    return step2

# ============== CLI Entry Point ==============
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("input", help="Input to process")
    args = parser.parse_args()

    result = main_workflow(args.input)
    print(result)
```

---

## Customizing Generation

### Provide More Context

```python
result = generate_program(
    task_description="""
    Analyze customer support tickets with the following requirements:

    1. Extract the main issue from the ticket
    2. Determine urgency (critical/high/medium/low)
    3. Identify the relevant department
    4. Suggest a response template

    The system should handle:
    - Technical issues (bugs, errors)
    - Billing questions
    - Feature requests
    - General inquiries
    """,
    input_spec={
        "ticket_text": "The full text of the support ticket",
        "customer_tier": "Optional: 'free', 'pro', or 'enterprise'"
    },
    output_spec="""
    {
        "issue_summary": "Brief summary of the issue",
        "urgency": "critical/high/medium/low",
        "department": "engineering/billing/product/support",
        "suggested_response": "Template response text"
    }
    """
)
```

### Control ptool Granularity

```python
generator = ProgramGenerator(
    max_ptools=5,              # Fewer, more general ptools
    prefer_composition=True,   # Compose smaller ptools
)

# Or generate more specialized ptools
generator = ProgramGenerator(
    max_ptools=15,
    prefer_composition=False,  # More specialized ptools
)
```

---

## When to Use Mode 2

**Good for:**
- Starting a new project from scratch
- Exploring how to structure a solution
- Rapid prototyping
- Generating boilerplate code

**Consider Mode 1 when:**
- You already know what ptools you need
- You're adding to existing code
- You want fine-grained control

**Consider Mode 3 when:**
- The task requires dynamic reasoning
- You don't know the steps in advance
- The workflow depends on intermediate results

---

## Tips for Better Generation

1. **Be specific about I/O**: Clear input/output specs lead to better ptools
2. **Describe edge cases**: Mention what the program should handle
3. **Give examples**: Include sample inputs/outputs in the description
4. **Start small**: Generate simple programs first, then iterate

---

## Next Steps

- **Use ptools directly**: See [Mode 1: @ptool Decorator](mode-1-ptool-decorator.md)
- **Dynamic reasoning**: See [Mode 3: ReAct Agent](mode-3-react-agent.md)
- **Optimize with distillation**: See [Architecture: Behavior Distillation](architecture.md#behavior-distillation)
